/*************************************************************
 * group_chat.cpp
 * Generated by corpc framework corpc_gen.py
 * Create Time: 2023-01-11 09:45:23
 * This file will not be overwrite althrough protobuf file changed !!!
 * Just write this file while not exist
*************************************************************/

#include <corpc/common/log.h>
#include "ChatService/interface/group_chat.h"
#include "ChatService/pb/ChatService.pb.h"
#include "ChatService/lib/rocketmq/rocketmq.h"
#include "ChatService/dao/group_dao.h"
#include "ChatService/dao/user_dao.h"
#include "ChatService/common/business_exception.h"
#include "ChatService/common/const.h"
#include "ChatService/common/error_code.h"
#include <vector>
#include <string>
#include <corpc/net/tcp/tcp_client.h>
#include "ChatService/lib/json.hpp"
#include "ChatService/common/make_package.h"
#include "ChatService/protocol/chat_service_codec.h"
#include "ChatService/protocol/chat_service_data.h"


namespace ChatService {

extern RocketMQProducer::ptr gProducer;

using json = nlohmann::json;

GroupChatInterface::GroupChatInterface(const ::GroupChatRequest &request, ::GroupChatResponse &response)
    : request_(request), 
    response_(response)
{

}

GroupChatInterface::~GroupChatInterface()
{

}

void GroupChatInterface::run()
{
    //
    // Run your business at here
    // response_.set_ret_code(0);
    // response_.set_res_info("Succ");
    //
    int fromUserId = request_.from_user_id();
    int toGroupId = request_.to_group_id();
    std::string msg = request_.msg();

    UserDao userDao;
    User user = userDao.queryUserInfo(fromUserId);
    if (user.getState() == NOT_EXIST_STATE) {
        throw BusinessException(CURRENT_USER_NOT_EXIST, getErrorMsg(CURRENT_USER_NOT_EXIST), __FILE__, __LINE__);
    }

    GroupDao groupDao;
    Group group = groupDao.queryGroup(toGroupId);
    // 群组是否存在
    if (group.getId() == -1) {
        throw BusinessException(GROUP_NOT_EXIST, getErrorMsg(GROUP_NOT_EXIST), __FILE__, __LINE__);
    }

    // 消息发送者是否在这个群中
    if (groupDao.queryGroupUserRole(fromUserId, toGroupId).empty()) {
        throw BusinessException(USER_NOT_IN_GROUP, getErrorMsg(USER_NOT_IN_GROUP), __FILE__, __LINE__);
    }

    for (const auto &user : group.getUsers()) {
        int userid = user.getId();
        if (user.getState() == ONLINE_STATE) {
            // 用户在线，转发给对应的ProxyServer
            corpc::NetAddress::ptr addr = userDao.quetyUserHost(userid);
            if (!corpc::IPAddress::checkValidIPAddr(addr->toString())) {
                throw BusinessException(ILLEGAL_USER_HOST, getErrorMsg(ILLEGAL_USER_HOST), __FILE__, __LINE__);
            }
            if (addr->toString() == "0.0.0.0:0") {
                throw BusinessException(FORWARD_CHAT_MSG_FAILED, getErrorMsg(FORWARD_CHAT_MSG_FAILED), __FILE__, __LINE__);
            }

            // 生成转发的消息
            json js;
            js["msgid"] = FORWARDED_MSG;
            js["to"] = user.getId();
            js["msg"] = msg;

            ChatServiceStruct forwarded;
            forwarded.msgType = SERVER_FORWARD_MSG;
            forwarded.protocolData = js.dump();
            ChatServiceCodeC codec;
            corpc::TcpClient::ptr client = std::make_shared<corpc::TcpClient>(addr);

            codec.encode(client->getConnection()->getOutBuffer(), &forwarded);
            if (client->sendData()) {
                throw BusinessException(FORWARD_CHAT_MSG_FAILED, getErrorMsg(FORWARD_CHAT_MSG_FAILED), __FILE__, __LINE__);
            }
        }
        else if (user.getState() == OFFLINE_STATE) {
            // 用户不在线，发送给消息队列的SAVE_OFFLINE_MSG_TOPIC，异步进行离线消息存储
            if (!gProducer->send(SAVE_OFFLINE_MSG_TOPIC, std::to_string(userid), msg)) {
                throw BusinessException(SAVE_OFFLINE_MSG_FAILED, getErrorMsg(SAVE_OFFLINE_MSG_FAILED), __FILE__, __LINE__);
            }  
        }
    }
}

}